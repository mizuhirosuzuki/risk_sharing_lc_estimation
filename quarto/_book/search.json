[
  {
    "objectID": "laczo2015_dataprep.html#load-packages",
    "href": "laczo2015_dataprep.html#load-packages",
    "title": "1  Data preparation",
    "section": "1.1 Load packages",
    "text": "1.1 Load packages\n\npacman::p_load(\n  tidyverse,\n  kableExtra\n)"
  },
  {
    "objectID": "laczo2015_dataprep.html#load-datasets",
    "href": "laczo2015_dataprep.html#load-datasets",
    "title": "1  Data preparation",
    "section": "1.3 Load datasets",
    "text": "1.3 Load datasets\n\nload('Laczo2015/allest')\n\n\n1.3.1 Basic data processes of raw data\n\nnumVillages <- max(villagedat)\nvillageIndicatorMatrix <- do.call(\n  cbind,\n  map(\n    seq(1, numVillages),\n    ~ villagedat[, 1] == .\n  )\n)\n\n\ncreateVillageAggregateByYear <- function(\n    data, \n    func, \n    .numVillages = numVillages, \n    .villageIndicatorMatrix = villageIndicatorMatrix\n    ) {\n  do.call(\n    rbind, \n    map(\n      seq(1, .numVillages),\n      ~ data[.villageIndicatorMatrix[, .],] %>% func\n      )\n    )\n  }\n\ncreateVillageAggregate <- function(\n    data, \n    func, \n    .numVillages = numVillages, \n    .villageIndicatorMatrix = villageIndicatorMatrix\n    ) {\n    map_vec(\n      seq(1, .numVillages),\n      ~ data[.villageIndicatorMatrix[, .],] %>% func\n    )\n  }\n\n\nvilMeanIncByYear <- createVillageAggregateByYear(incdat, colMeans)\nvilSumIncByYear <- createVillageAggregateByYear(incdat, colSums)\nvilMeanInc <- createVillageAggregate(incdat, mean)\nvilMeanConsByYear <- createVillageAggregateByYear(consdat, colMeans)\nvilSumConsByYear <- createVillageAggregateByYear(consdat, colSums)\nvilMeanCons <- createVillageAggregate(consdat, mean)\n\n\nvilMeanEduc <- createVillageAggregate(educdat, mean)\nvilMeanWomenShare <- createVillageAggregate(propfdat, mean)\nvilMeanAge <- createVillageAggregate(educdat, mean)\nvilMeanLand <- createVillageAggregate(educdat, mean)\n\n\nincLow <- createVillageAggregate(incdat, function(x) quantile(x, 0.025, na.rm = TRUE))\nincHigh <- createVillageAggregate(incdat, function(x) quantile(x, 0.975, na.rm = TRUE))\nconsLow <- createVillageAggregate(consdat, function(x) quantile(x, 0.025, na.rm = TRUE))\nconsHigh <- createVillageAggregate(consdat, function(x) quantile(x, 0.975, na.rm = TRUE))\n\n\nvilConsPerIncByYear <- vilMeanConsByYear / vilMeanIncByYear\nincdatRescaled <- incdat * (villageIndicatorMatrix %*% vilConsPerIncByYear)\nvilMeanIncByYearRescaled <- createVillageAggregateByYear(incdatRescaled, colMeans)"
  },
  {
    "objectID": "laczo2015_dataprep.html#estimate-income-processes",
    "href": "laczo2015_dataprep.html#estimate-income-processes",
    "title": "1  Data preparation",
    "section": "1.4 Estimate income processes",
    "text": "1.4 Estimate income processes\nThe main step of this data processing is to estimate the income process, first of households and second of the “village” (= average of households in a village). We want the income process of the village since, in estimation, we consider the risk-sharing transfers between a household and the village so that we can consider one-to-one transfers instead of on-to-n transfers.\nFor this, first I estimate the income process of households by types, where the types are by income’s mean and coefficient of variance (CV). Here, in total we have 4 types (high/low mean income X high/low CV income). If there were long enough income data, we would have been able to estimate the income process of each household, but given the 6 observations per household for income in ICRISAT data, the author took this approach.\nThis estimation process is detailed in the paper’s online appendix\n\nnumIncomeStatesHH <- 8\nnumIncomeStatesVillage <- 5\n\n\n1.4.1 Household\n\nhouseholdIncMean <- incdatRescaled %>% rowMeans\nhouseholdIncSD <- apply(incdatRescaled, 1, sd, na.rm = TRUE)\nhouseholdIncCV <- householdIncSD / householdIncMean\n\nvilIncMeanMedian <- createVillageAggregate(\n  as.matrix(householdIncMean), \n  median\n  )\nvilIncCVMedian <- createVillageAggregate(\n  as.matrix(householdIncCV), \n  median\n  )\n\n\n1.4.1.1 Estimate AR(1) process\nFirst I estimate the AR(1) process of households’ income. In particular, the following AR(1) process is estimated:\n\n  y_{it} = (1 - \\rho) \\mu + \\rho y_{i, t - 1} + u_{it},\n\nwhere y_{it} is the income of a household i in period t.\nThe parameters are given as\n\n  \\mu = E(y_{it}) \\\\\n  \\rho = Cor(y_{it}, y_{i, t - 1}) \\\\\n  \\sigma_{u}^2 = (1 - \\rho^2) Var(y_{it}).\n\n\nhouseholdIncMeanClassVec <- (householdIncMean > (villageIndicatorMatrix %*% vilIncMeanMedian)) + 1\nhouseholdIncCVClassVec <- (householdIncCV > (villageIndicatorMatrix %*% vilIncCVMedian)) + 1\n\nlaggedIncdatRescaled <- cbind(NA, incdatRescaled[, seq(1, tnum - 1)])\nincdatRescaled[\n  (incdat <= as.vector(villageIndicatorMatrix %*% incLow)) |\n    (incdat >= as.vector(villageIndicatorMatrix %*% incHigh))] <- NA\nlaggedIncdatRescaled[\n  (incdat <= as.vector(villageIndicatorMatrix %*% incLow)) |\n    (incdat >= as.vector(villageIndicatorMatrix %*% incHigh))] <- NA\n\ngetDataByMeanCVClassByVillage <- function(\n    village, \n    data, \n    meanClass, \n    CVClass,\n    meanClassVec = householdIncMeanClassVec,\n    CVClassVec = householdIncCVClassVec,\n    .villageIndicatorMatrix = villageIndicatorMatrix\n    ) {\n  data[\n    (meanClassVec == meanClass) & \n      (CVClassVec == CVClass) &\n      (.villageIndicatorMatrix[, village])\n  ]\n}\n\ncalculateAR1Parameters <- function(data, laggedData) {\n  mu <- mean(data, na.rm = TRUE)\n  rho <- cor(\n    data,\n    laggedData,\n    use=\"complete.obs\"\n    )\n  sigmau <- sqrt(var(data, na.rm = TRUE) * (1 - rho^2))\n  \n  return(list(mu = mu, rho = rho, sigmau = sigmau))\n}\n\n\n\n1.4.1.2 Approximate the AR(1) process with Markov chain for income of households\nGiven the estimated parameters, I approximate the AR(1) process with discretization. For this, the author used Tauchen’s method with a small modification that, instead of assigning the bounds of grid points with a parameter, the quantiles of income distributions are used to determine each grid point.\n\ncalculateGridPoints <- function(numStates, data) {\n  gridQuantile <- seq(0, 1, by = 1 / numStates)\n  map_dbl(\n    (gridQuantile[1:(length(gridQuantile) - 1)] + gridQuantile[2:length(gridQuantile)]) / 2,\n    ~ quantile(data, ., na.rm = TRUE)\n  )\n}\n\napproximateAR1Tauchen <- function(numStates, data, mu, rho, sigma) {\n  \n  gridPoints <- calculateGridPoints(numStates, data)\n  \n  transitionMatrix <- array(NA, c(numStates, numStates))\n  for (currentState in 1:numStates) {\n    transitionMatrix[currentState, 1] <- (\n      pnorm(\n        ((gridPoints[2] + gridPoints[1]) / 2 \n         - (1 - rho) * mu - rho * gridPoints[currentState])\n        / sigma\n        )\n      )\n    transitionMatrix[currentState, numStates] <- 1 - pnorm(\n      ((gridPoints[numStates] + gridPoints[numStates - 1]) / 2 \n       - (1 - rho) * mu - rho * gridPoints[currentState])\n      / sigma\n      )\n    }\n  for (currentState in 1:numStates) {\n    for (nextState in 2:(numStates - 1)) {\n        transitionMatrix[currentState, nextState] <- (\n          pnorm(\n          ((gridPoints[nextState + 1] + gridPoints[nextState]) / 2 \n           - (1 - rho) * mu - rho * gridPoints[currentState])\n          / sigma\n          )\n        - pnorm(\n          ((gridPoints[nextState] + gridPoints[nextState - 1]) / 2 \n           - (1 - rho) * mu - rho * gridPoints[currentState])\n          / sigma\n          )\n          )\n        }\n    }\n  return(list(transitionMatrix = transitionMatrix, gridPoints = gridPoints))\n}\n\ncalculateSteadyStateProb <- function(transitionMatrix) {\n  (\n    eigen(t(transitionMatrix))$vector[, 1]\n    / sum(eigen(t(transitionMatrix))$vector[, 1])\n  )\n}\n\nrescaleGridPoints <- function(transitionMatrix, gridPoints, data) {\n  steadyStateProb <- calculateSteadyStateProb(transitionMatrix)\n  rescaleScalar <- as.numeric(\n    mean(data, na.rm = TRUE) / gridPoints \n    %*% steadyStateProb\n    )\n  gridPointsRescaled <- gridPoints * rescaleScalar\n  return(list(gridPointsRescaled = gridPointsRescaled, steadyStateProb = steadyStateProb))\n}\n\napproximateAR1TauchenWithRescaling <- function(numStates, data, mu, rho, sigma) {\n  TauchenResult <- approximateAR1Tauchen(numStates, data, mu, rho, sigma)\n  transitionMatrix <- TauchenResult$transitionMatrix\n  gridPoints <- TauchenResult$gridPoints\n  gridPointsRescaledResult <- rescaleGridPoints(\n    transitionMatrix, gridPoints, data\n    )\n  gridPointsRescaled <- gridPointsRescaledResult$gridPointsRescaled\n  steadyStateProb <- gridPointsRescaledResult$steadyStateProb\n  \n  return(list(\n    transitionMatrix = transitionMatrix, \n    gridPointsRescaled = gridPointsRescaled,\n    steadyStateProb = steadyStateProb\n    ))\n}\n\nestimateHouseholdIncomeTransitionProcessByVillage <- function(\n    village,\n    numStates,\n    data,\n    laggedData\n) {\n  gridPointsArray <- array(NA, c(2, 2, numStates))\n  transitionMatrixArray <- array(NA, c(2, 2, numStates, numStates))\n  steadyStateProbArray <- array(NA, c(2, 2, numStates)) \n  AR1ParametersArray <- array(NA, c(2, 2, 3))\n  \n  for (incomeMeanClass in seq(1, 2)) {\n    for (incomeCVClass in seq(1, 2)) {\n      incdatRescaledMeanCVClass <- getDataByMeanCVClassByVillage(\n        village, data, incomeMeanClass, incomeCVClass\n        )\n      laggeedIncdatRescaledMeanCVClass <- getDataByMeanCVClassByVillage(\n        village, laggedData, incomeMeanClass, incomeCVClass\n        )\n      AR1Parameters <- calculateAR1Parameters(incdatRescaledMeanCVClass, laggeedIncdatRescaledMeanCVClass)\n      TauchenResult <- approximateAR1TauchenWithRescaling(\n        numIncomeStatesHH, incdatRescaledMeanCVClass, \n        AR1Parameters$mu, AR1Parameters$rho, AR1Parameters$sigmau\n        )\n      gridPointsArray[incomeMeanClass, incomeCVClass,] <- TauchenResult$gridPoints\n      transitionMatrixArray[incomeMeanClass, incomeCVClass,,] <- TauchenResult$transitionMatrix\n      steadyStateProbArray[incomeMeanClass, incomeCVClass,] <- TauchenResult$steadyStateProb\n      AR1ParametersArray[incomeMeanClass, incomeCVClass,] <- unlist(AR1Parameters)\n    }\n  }\n  \n  return(list(\n    gridPointsArray = gridPointsArray,\n    transitionMatrixArray = transitionMatrixArray,\n    steadyStateProbArray = steadyStateProbArray,\n    AR1ParametersArray = AR1ParametersArray\n    ))\n}\n  \nhouseholdAR1EstimationResult <- map(\n  seq(1, numVillages),\n  ~ estimateHouseholdIncomeTransitionProcessByVillage(., numIncomeStatesHH, incdatRescaled, laggedIncdatRescaled)\n)\n\n\n\n\n\n\n\n1.4.2 Village\nGiven the estimated household income processes, I estimate the income process of the “village”. For this, I first simulate the average village income, using the parameters estimated above. In particular, I simulate the household income over 1000 periods, then compute the mean income in each period. After excluding the first 100 observations to use the income at the steady state, I estimate the parameters using the same method as for the household income.\n\n1.4.2.1 Simulate income process for village\n\nnumVillageIncomeSimulations <- 1000\nnumVillageIncomeSimulationsPeriodDrop <- 100\n\nsample1stPeriodIncomeStateByMeanCVClass <- function(\n    meanClass, \n    CVClass, \n    numStates, \n    steadyStateProbArray\n    ) {\n  sample(\n    seq(1, numStates),\n    1,\n    prob = steadyStateProbArray[meanClass, CVClass, ]\n    )\n}\n\nsampleConditionalIncomeStateByMeanCVClass <- function(\n    meanClass, \n    CVClass,\n    numStates,\n    transitionMatrixArray,\n    previousState\n) {\n  sample(\n    seq(1, numStates),\n    1,\n    prob = transitionMatrixArray[meanClass, CVClass, previousState,]\n  )\n}\n\nsampleAllIncomeStateByMeanCVClass <- function(\n    meanClass, \n    CVClass,\n    numStates,\n    steadyStateProbArray,\n    transitionMatrixArray,\n    numSimulation = numVillageIncomeSimulations\n) {\n  incomeStateVector <- vector(mode = \"integer\", length = numSimulation)\n  incomeStateVector[1] <- sample1stPeriodIncomeStateByMeanCVClass(\n    meanClass, \n    CVClass, \n    numStates, \n    steadyStateProbArray\n    )\n  for (period in seq(2, numSimulation)) {\n    incomeStateVector[period] <- sampleConditionalIncomeStateByMeanCVClass(\n      meanClass, \n      CVClass,\n      numStates,\n      transitionMatrixArray,\n      incomeStateVector[period - 1]\n      )\n  }\n  return(incomeStateVector)\n}\n\nsimulateHouseholdIncomeByMeanCVClass <- function(\n    meanClass, \n    CVClass,\n    numStates,\n    steadyStateProbArray,\n    transitionMatrixArray,\n    gridPointsArray,\n    numSimulation = numVillageIncomeSimulations\n) {\n  incomeStateVec <- sampleAllIncomeStateByMeanCVClass(\n    meanClass, \n    CVClass,\n    numStates,\n    steadyStateProbArray,\n    transitionMatrixArray)\n  gridPointsArray[meanClass, CVClass, incomeStateVec]\n}\n\nsimulateHouseholdIncomeByVillage <- function(\n    village,\n    meanClassVec,\n    CVClassVec,\n    numStates,\n    householdAR1EstimationResult,\n    .villageIndicatorMatrix = villageIndicatorMatrix\n) {\n  \n  meanClassVillage <- meanClassVec[villageIndicatorMatrix[, village]]\n  CVClassVillage <- CVClassVec[villageIndicatorMatrix[, village]]\n  steadyStateProbArrayVillage <- householdAR1EstimationResult[[village]]$steadyStateProbArray\n  transitionMatrixArrayVillage <- householdAR1EstimationResult[[village]]$transitionMatrixArray\n  gridPointsArrayVillage <- householdAR1EstimationResult[[village]]$gridPointsArray\n  \n  do.call(\n    rbind,\n    map2(\n      meanClassVillage, CVClassVillage,\n      ~ simulateHouseholdIncomeByMeanCVClass(\n        .x, .y, numStates, steadyStateProbArrayVillage, transitionMatrixArrayVillage, gridPointsArrayVillage\n        )\n    )\n  )\n  \n}\n\nsimulatedHouseholdIncome <- map(\n  seq(1, numVillages),\n  ~ simulateHouseholdIncomeByVillage(\n    .,\n    householdIncMeanClassVec,\n    householdIncCVClassVec,\n    numIncomeStatesHH,\n    householdAR1EstimationResult\n    ) \n)\n\nestimateVillagencomeTransitionProcessByVillage <- function(\n    village,\n    meanClassVec,\n    CVClassVec,\n    numStatesHH,\n    numStatesVillage,\n    householdAR1EstimationResult,\n    .villageIndicatorMatrix = villageIndicatorMatrix,\n    .numVillageIncomeSimulationsPeriodDrop = numVillageIncomeSimulationsPeriodDrop,\n    .numVillageIncomeSimulations = numVillageIncomeSimulations\n){\n  householdIncomeSimulationResult <- simulateHouseholdIncomeByVillage(\n    village,\n    meanClassVec,\n    CVClassVec,\n    numStatesHH,\n    householdAR1EstimationResult\n  )\n  \n  villageSimulatedIncMean <- colMeans(\n    householdIncomeSimulationResult[, .numVillageIncomeSimulationsPeriodDrop:.numVillageIncomeSimulations]\n  )\n  villageSimulatedIncLogMean <- colMeans(\n    householdIncomeSimulationResult[, .numVillageIncomeSimulationsPeriodDrop:.numVillageIncomeSimulations]\n  ) %>% log\n  villageSimulatedLaggedIncLogMean <- colMeans(\n    householdIncomeSimulationResult[\n      , (.numVillageIncomeSimulationsPeriodDrop - 1):(.numVillageIncomeSimulations - 1)\n      ]\n  ) %>% log\n  \n  villageAR1Parameters <- calculateAR1Parameters(\n    villageSimulatedIncLogMean,\n    villageSimulatedLaggedIncLogMean \n  )\n  \n  villageAR1TauchenApproximation <- approximateAR1Tauchen(\n    numStatesVillage, villageSimulatedIncLogMean, \n    villageAR1Parameters$mu, villageAR1Parameters$rho, villageAR1Parameters$sigmau\n  )\n  \n  villageIncomeGridPoints <- calculateGridPoints(numStatesVillage, villageSimulatedIncMean)\n\n  villageIncomeGridPointsRescaled <- rescaleGridPoints(\n      villageAR1TauchenApproximation$transitionMatrix, \n      villageIncomeGridPoints,\n      villageSimulatedIncMean\n      )\n  \n  return(list(\n    transitionMatrix = villageAR1TauchenApproximation$transitionMatrix,\n    gridPoints = villageIncomeGridPointsRescaled$gridPointsRescaled\n  ))\n}\n\n\nvillageAR1EstimationResult <- map(\n  seq(1, numVillages),\n  ~ estimateVillagencomeTransitionProcessByVillage(\n      .,\n      householdIncMeanClassVec,\n      householdIncCVClassVec,\n      numIncomeStatesHH,\n      numIncomeStatesVillage,\n      householdAR1EstimationResult\n  )\n)"
  },
  {
    "objectID": "laczo2015_dataprep.html#sanity-check-compare-against-the-parameters-in-the-original-paper",
    "href": "laczo2015_dataprep.html#sanity-check-compare-against-the-parameters-in-the-original-paper",
    "title": "1  Data preparation",
    "section": "1.5 Sanity check: compare against the parameters in the original paper",
    "text": "1.5 Sanity check: compare against the parameters in the original paper\nJust for a sanity check of my code, I compare the household AR(1) process parameters I derived against the ones provided in the appendix of the paper. The parameters in the tables below coincide to the parameters in the paper appendix, excpet the ones for “Low mean, high risk” in Shirapur. I reran the original R script and confirmed that the correct parameters are the ones that I am showing in the table below.\nSince I refactored the origianl R script, I cannot reproduce the village parameters. To be clear, the author has set the random seed in the code, and the reason I cannot reproduce the village parameters is merely because of the difference in code structures.\n\ncreateParameterTableByVillage <- function(\n    village,\n    householdAR1EstimationResult\n) {\n  \n  villageParameters <- array(NA, c(3, 4))\n  colIndex <- 0\n  for (incomeMeanClass in seq(1, 2)) {\n    for (incomeCVClass in seq(1, 2)) {\n      colIndex <- colIndex + 1\n      villageParameters[, colIndex] <- \n        householdAR1EstimationResult[[village]]$AR1ParametersArray[incomeMeanClass, incomeCVClass,]\n    }\n  }\n  rownames(villageParameters) <- c(\n    \"mu\",\n    \"rho\",\n    \"sigmau_squared\"\n  )\n  villageParameters %>% \n    kbl(digits = 3) %>% \n    kable_classic() %>% \n    add_header_above(\n      c(\n        \"\",\n        \"Low mean, \\n low risk\",\n        \"Low mean, \\n high risk\",\n        \"High mean, \\n low risk\",\n        \"High mean, \\n high risk\"\n      )\n    )\n}\ncreateParameterTableByVillage(1, householdAR1EstimationResult)\n\n\n\n\n\nLow mean,  low risk\nLow mean,  high risk\nHigh mean,  low risk\nHigh mean,  high risk\n\n\n  \n    mu \n    182.475 \n    160.201 \n    441.843 \n    391.798 \n  \n  \n    rho \n    0.189 \n    0.626 \n    0.550 \n    0.365 \n  \n  \n    sigmau_squared \n    49.088 \n    68.506 \n    128.741 \n    188.458 \n  \n\n\n\n\ncreateParameterTableByVillage(2, householdAR1EstimationResult)\n\n\n\n\n\nLow mean,  low risk\nLow mean,  high risk\nHigh mean,  low risk\nHigh mean,  high risk\n\n\n  \n    mu \n    235.906 \n    243.872 \n    506.555 \n    525.520 \n  \n  \n    rho \n    0.491 \n    0.285 \n    0.846 \n    0.520 \n  \n  \n    sigmau_squared \n    45.808 \n    79.111 \n    122.302 \n    237.918 \n  \n\n\n\n\ncreateParameterTableByVillage(3, householdAR1EstimationResult)\n\n\n\n\n\nLow mean,  low risk\nLow mean,  high risk\nHigh mean,  low risk\nHigh mean,  high risk\n\n\n  \n    mu \n    263.292 \n    288.625 \n    446.590 \n    642.628 \n  \n  \n    rho \n    0.318 \n    -0.150 \n    0.160 \n    0.199 \n  \n  \n    sigmau_squared \n    78.793 \n    126.987 \n    129.785 \n    271.997"
  },
  {
    "objectID": "laczo2015_dataprep.html",
    "href": "laczo2015_dataprep.html",
    "title": "1  My document",
    "section": "",
    "text": "2 Laczo (2015) R scripts for data preparation"
  },
  {
    "objectID": "laczo2015_dataprep.html#global-settings",
    "href": "laczo2015_dataprep.html#global-settings",
    "title": "1  Data preparation",
    "section": "1.2 Global settings",
    "text": "1.2 Global settings\n\nset.seed(123)"
  }
]