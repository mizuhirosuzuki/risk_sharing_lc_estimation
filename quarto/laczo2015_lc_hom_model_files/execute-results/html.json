{
  "hash": "11059ff61b88a8a7765087aca5fe33f6",
  "result": {
    "markdown": "---\ntitle: \"Risk sharing with limited commitoment: model\"\nbibliography: references.bib\nformat:\n  html:\n    toc: true\n    html-math-method: katex\n    css: styles.css\n---\n\n\nHere I demonstrate how to compute value functions and consumption under risk-sharing with limited commitment.\nFirst I show the risk-sharing model with limited commitment, and then I show the calculation of value functions.\n\n## Model\n\nI consider constrained-efficient consumptioon allocatinos. \nThe social planner solves the following problem:\n\n\n```{=tex}\n\\begin{align*}\n  &\\max_{\\{c_{it}(s^t)\\}} \\sum_i \\lambda_i \\sum_{t = 1}^{\\infty} \\sum_{s^t} \\delta^t \\pi(s^t) u(c_{it}(s^t)) \\\\\n  \\text{subject to} \n  &\\sum_i c_{it} (s^t) \\le \\sum_i y_{it}(s_t) \\quad \\forall s^t, \\forall t \\\\\n  &\\sum_{r = t}^{\\infty} \\sum_{s^r} \\delta^{r - t} \\pi(s^r | s^t) u(c_{ir}(s^r)) \\ge U_{i}^{aut}(s_t) \\quad \\forall s^t, \\forall t, \\forall i.\n\\end{align*}\n```\n\nHere, the income follows a Markov process and is independent across households. Notice the difference between the history of states up to period $t$ ($s^t$) and the state at period $t$ ($s_t$). The variable $\\lambda_i$ is the Pareto weight of a household $i$. The last equation is the participation constraints (PCs), whose RHS is the value of autarky and the solution of the following Bellman equation:\n\n$$\n  U_i^{aut}(s_t) = u((1 - \\phi) y_{it}(s_t)) + \\delta \\sum_{s^{t + 1}} \\pi(s_{t + 1} | s_t) U_{i}^{aut}(s_{t + 1}),\n$$ where $\\phi$ is the punishment of renege, which is a fraction of consumption each period. It is assumed that savings are absent.\n\nLetting the multiplier on the PC of $i$ be $\\delta^t \\pi(s^t) \\mu_i(s^t)$ and the multiplier on the aggregate resource constraint be $\\delta^t \\pi(s^t) \\rho(s^t)$, the Lagrangian is\n\n$$\n  \\sum_{t = 1}^{\\infty} \\sum_{s^t} \\delta^t \\pi(s^t) \\left\\{ \\sum_i \\left[ \\lambda_i u_i(c_{it}(s^t)) + \\mu_i(s^t) \\left( \\sum_{r = t}^{\\infty} \\sum_{s^r} \\delta^{r - t} \\pi(s^r | s^t) u_i (c_{ir} (s^r)) - U_i^{aut}(s_t) \\right) \\right] + \\rho(s^t) \\left( \\sum_i \\left(y_{it} (s_t) - c_{it} (s^t) \\right) \\right) \\right\\}\n$$ With the recursive method in @Marcet2019, this Lagrangian can be written as\n\n$$\n  \\sum_{t = 1}^{\\infty} \\sum_{s^t} \\delta^t \\pi(s^t) \\left\\{ \\sum_i \\left[ M_i (s^{t - 1}) u_i (c_{it} (s^t)) + \\mu_i (s^t) (u_i (c_{it} (s^t)) - U_i^{aut} (s_t)) \\right] + \\rho(s^t) \\left( \\sum_i \\left( y_{it}(s_t) - c_{it} (s^t) \\right) \\right) \\right\\},\n$$\n\nwhere $M_i(s^t) = M_i(s^{t - 1}) + \\mu_i(s^t)$ and $M_i(s^0) = \\lambda$. The variable $M_i(s^t)$ is the current Pareto weight of household $i$ and is equal to its initial Pareto weight plus the sum of the Lagrange mulipliers on its PCs along the history $s^t$.\n\nFrom the Lagrangian, the optimality condition is\n$$\n  u_i'(c_{it}(s^t)) M_i(s^t) = \\frac{\\rho(s^t)}{\\delta^t \\pi(s^t)},\n$$\nand thus, for two households $i$ and $j$ ($i \\ne j$),\n$$\n  u_i'(c_{it}(s^t)) M_i(s^t) = u_j'(c_{jt}(s^t)) M_j(s^t).\n$$\nTaking logarithms and summing over households $j$, I get\n$$\n\\begin{aligned}\n  \\log \\left(u'('c_{it}(s^t)) \\right) + \\log \\left(M_i(s^t) \\right) = \\frac{1}{N} \\sum_j \\log \\left(u(c_{jt}(s^t)) \\right) + \\frac{1}{N} \\sum_j \\log \\left(M_j(s^t) \\right).\n\\end{aligned}\n$$\nDefining the village consumption $c_{vt}$ such that $\\log \\left(u'(c_{vt}(s^t)) \\right) = \\frac{1}{N} \\sum_j \\log \\left(u(c_{jt}(s^t)) \\right)$ and normalizing the Pareto weight so that $\\frac{1}{N} \\sum_j \\log \\left(M_j(s^t) \\right) = 0$, I obtain\n$$\n\\begin{aligned}\n  \\log \\left(u'('c_{it}(s^t)) \\right) + \\log \\left(M_i(s^t) \\right) &= \\log \\left(u'(c_{vt}(s^t)) \\right) \\\\\n  \\Leftrightarrow \\frac{u'(c_{vt}(s^t))}{u'(c_{it}(s^t))} = M_i(s^t)\n\\end{aligned}\n$$\nNote that this is equivalent to the optimality condition that the ratio of marginal utilities between two \"households\", $i$ and $v$, equals the ratio of their Pareto weights, where the Pareto weight of $v$ is normalized to $1$.\nTherefore, when I consider the one-versus-rest risk-sharing, I can use this optimality condition as if the village is one household.\n\nLet $x_i(s^t) = M_i(s^t)$, the \"relative\" Pareto weight of household $i$ under the history $s^t$.\nThen, the vector of relative weights $x(s^t)$ plays as a role as a co-state variable, and the solution consists of policy functions $x_{it}(s_t, x_{t - 1})$ and $c_{it}(s_t, x_{t - 1}).$\nThat is, $x_{t - 1}$ is a sufficient statistic for the history up to $t - 1$. The optimality condition is\n\n$$\n  \\frac{u_v'(c_{vt}(s_t, x_{t - 1}))}{u_i'(c_{it}(s_t, x_{t - 1}))} = x_{it}(s_t, x_{t - 1}) \\quad \\forall i.\n$$\n\nThe value functioon can be written recursively as\n\n$$\n  V_i(s_t, x_{t - 1}) = u_i (c_{it} (s_t, x_{t - 1})) + \\delta \\sum_{s_{t + 1}} \\pi(s_{t + 1} | s_t) V_i (s_{t + 1}, x_t(s_t, x_{t - 1})).\n$$\n\nThe evolution of relative Pareto weights is fully characterized by state-dependent intervals, which give the weights in the case where PCs are binding (@Ligon2002).\n\n\n## Code\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(\n  tidyverse,\n  kableExtra,\n  latex2exp\n)\n```\n:::\n\n\n### Utility functions\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalculateUtility <- function(cons, sigma) {\n  if (sigma != 1) {\n    utility = (cons^(1 - sigma) - 1) / (1 - sigma)\n  } else if (sigma == 1) {\n    utility = log(cons)\n  }\n  return(utility)\n}\ncalculateMarginalUtility <- function(cons, sigma) cons^(- sigma)\n```\n:::\n\n\n### Value of autarky\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalculateAutarkyValue <- function(\n    incomeGridPoints, \n    sigma,\n    delta,\n    punishment,\n    incomeTransitionMatrix\n) {\n  \n  autarkyValue <- numeric(length = length(incomeGridPoints))\n  i <- 1\n  diff <- 1\n  while (diff > 1e-12) {\n    autarkyValueNew <- (\n      calculateUtility(incomeGridPoints * (1 - punishment), sigma) \n      + delta * incomeTransitionMatrix %*% autarkyValue\n    )\n    diff <- max(abs(autarkyValueNew - autarkyValue))\n    autarkyValue <- autarkyValueNew\n    i <- i + 1\n  }\n  return(autarkyValue)\n}\n```\n:::\n\n\n### Create grid of relative Pareto weights\n\nHere, I make the grid of relative Pareto weight of household 1, $x(s^t)$, on which I compute the values (I use the notation $x(s^t)$ rather than $x_i(s^t)$ since there are only two households).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngetRelativeParetoWeightsGridPoints <- function(\n    sigma,\n    punishment,\n    householdIncomeGridPoints,\n    villageIncomeGridPoints,\n    numRelativeParetoWeights\n    ) {\n  \n  minRelativeParetoWeights <- (\n    calculateMarginalUtility(max(villageIncomeGridPoints), sigma) \n    / calculateMarginalUtility(min(householdIncomeGridPoints * (1 - punishment)), sigma)\n  )\n  maxRelativeParetoWeights <- (\n    calculateMarginalUtility(min(villageIncomeGridPoints * (1 - punishment)), sigma) \n    / calculateMarginalUtility(max(householdIncomeGridPoints), sigma)\n  )\n  relativeParetoWeightsGridPoints <- exp(\n    seq(log(minRelativeParetoWeights), log(maxRelativeParetoWeights), length.out = numRelativeParetoWeights)\n    )\n  return(relativeParetoWeightsGridPoints)\n}\n```\n:::\n\n\n### Calculate consumption on the grid points\n \nThen, I compute consumptions of the household 1 on these grid points. From the optimality condition and the CRRA utility functions, we obtain\n\n$$\n  c_{1t} = \\frac{y_{1t} + y_{2t}}{1 + x_t^{- 1 / \\sigma}}.\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalculateConsumption <- function(\n  aggregateIncome,\n  relativeParetoWeight,\n  sigma\n) {\n    aggregateIncome / (1 + relativeParetoWeight^(- 1 / sigma))\n}\n```\n:::\n\n\n### Caclulate values under full risk-sharing\n\nNow, I compute the values under full risk-sharing, which will be used as the initial values in value function iterations under the limited commitment model.\nNote that, under full risk sharing, the consumption only depends on the aggregate resources and time-invariate relative Pareto weights.\nHence, I numerically solve the following Bellman equation:\n\n$$\n  V_i^{full}(s_t, x) = u_i(c_{it}(s_t, x)) + \\delta \\sum_{s^{t + 1}} \\pi(s_{t + 1} | s_t) V_{i}^{full}(s_{t + 1}, x).\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalculateValueFullRiskSharing <- function(\n  incomeTransitionMatrix, \n  aggregateIncomeGridPoints, \n  delta, \n  sigma, \n  autarkyValueMatrix, \n  consumptionOnRelativeParetoWeightGrid,\n  numRelativeParetoWeights\n  ) {\n\n  # Initial guess is expected utilities under autarky\n  householdValueFullRiskSharing <- outer(\n    autarkyValueMatrix[, 1], rep(1, numRelativeParetoWeights)\n    )\n  villageValueFullRiskSharing <- outer(\n    autarkyValueMatrix[, 2], rep(1, numRelativeParetoWeights)\n    )\n\n  iteration <- 1\n  diff <- 1\n  while (diff > 1e-10 & iteration < 500) {\n    householdValueFullRiskSharingNew <- (\n      calculateUtility(consumptionOnRelativeParetoWeightGrid, sigma) \n      + delta * incomeTransitionMatrix %*% householdValueFullRiskSharing\n    )\n    villageValueFullRiskSharingNew <- (\n      calculateUtility(aggregateIncomeGridPoints - consumptionOnRelativeParetoWeightGrid, sigma) \n      + delta * incomeTransitionMatrix %*% villageValueFullRiskSharing\n    )\n    diff <- max(\n      max(abs(householdValueFullRiskSharing - householdValueFullRiskSharingNew)), \n      max(abs(villageValueFullRiskSharing - villageValueFullRiskSharingNew))\n      )\n    householdValueFullRiskSharing <- householdValueFullRiskSharingNew\n    villageValueFullRiskSharing <- villageValueFullRiskSharingNew\n    iteration <- iteration + 1\n  }\n\n  return(list(\n    householdValueFullRiskSharing = householdValueFullRiskSharing, \n    villageValueFullRiskSharing = villageValueFullRiskSharing\n    ))\n}\n```\n:::\n\n\n### Values under risk-sharing (limited commitment)\n\nNext, I derive the state-dependent intervals of relative Pareto weights and calculate values under the model of limited commitment. To derive the intervals, I use the fact that at the limits of the intervals, the PCs are binding. For instance, to compute the lower limit $\\underline{x}^h(s)$, where $h$ indicates $h$'th iteration, the PC of the household 1 is binding:\n\n$$\n  u_1(c_1^h(s)) + \\delta \\sum_{s'} \\pi(s' | s) V_1^{h - i} (s', \\underline{x}^h(s)) = U_1^{aut}(s),\n$$ \nwhere the optimality condition is\n\n$$\n  \\frac{u_2'(c_{2}^h(s))}{u_1'(c_{1}^h(s))} = \\underline{x}^h(s).\n$$\n\nNotice that, once the PC binds, the past history, which is summarized by $x_{t - 1}$, does not matter. This property is called \"amnesia\" (@Kocherlakota1996) or \"forgiveness\" (@Ligon2002). Since $\\underline{x}^h(s)$ may not be on the grid $q$, linear interpolation is used to compute $V_1^{h - 1}(s', \\underline{x}^h(s))$.\n\nSimilarly, $\\overline{x}^h(s)$ is computed using the binding PC of the household 2\n\n$$\n  u_2(c_2^h(s)) + \\delta \\sum_{s'} \\pi(s' | s) V_2^{h - i} (s', \\overline{x}^h(s)) = U_2^{aut}(s),\n$$ \nwhere the optimality condition is\n\n$$\n  \\frac{u_2'(c_{2}^h(s))}{u_1'(c_{1}^h(s))} = \\overline{x}^h(s).\n$$\n\nAfter deriving these limits of intervals,\n\n1.  for relative Pareto weights below $\\underline{x}^h(s)$, compute consumption of HH1 based on $\\underline{x}^h(s)$ and let its value be $U_1^{aut}$;\n2.  for relative Pareto weights above $\\overline{x}^h(s)$, compute consumption of HH1 based on $\\overline{x}^h(s)$ and let the value of HH2 be $U_2^{aut}$;\n3.  for other relative Pareto weights, use them to compute consumption of HH1 and the values of households.\n\nBy iterating these steps, we can calculate the value functions of households and limits of intervals.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninterpolateValueFunction <- function(\n    relativeParetoWeight,\n    relativeParetoWeightsGridPoints,\n    valueFunctionMatrix\n    ) {\n  apply(\n    valueFunctionMatrix,\n    1,\n    function(y) {\n      approxfun(\n        relativeParetoWeightsGridPoints, \n        y, \n        rule = 2\n        )(relativeParetoWeight)\n    }\n    )\n}\n\ncalculateDiffLCRiskSharingAndAutarky <- function(\n    relativeParetoWeight,\n    relativeParetoWeightsGridPoints,\n    delta,\n    sigma,\n    aggregateIncome,\n    householdValueLCRiskSharing,\n    villageValueLCRiskSharing,\n    incomeTransitionProbVec,\n    householdAutarkyValue,\n    villageAutarkyValue\n    ) {\n  \n  householdConsumption <- calculateConsumption(\n    aggregateIncome,\n    relativeParetoWeight,\n    sigma\n  )\n  \n  householdValueLCRiskSharingAtRelativeParetoWeight <- interpolateValueFunction(\n    relativeParetoWeight,\n    relativeParetoWeightsGridPoints,\n    householdValueLCRiskSharing\n    )\n  villageValueLCRiskSharingAtRelativeParetoWeight <- interpolateValueFunction(\n    relativeParetoWeight,\n    relativeParetoWeightsGridPoints,\n    villageValueLCRiskSharing\n    )\n  \n  householdDiffLCRiskSharingAndAutarky <- (\n    calculateUtility(householdConsumption, sigma) \n    + delta * incomeTransitionProbVec %*% householdValueLCRiskSharingAtRelativeParetoWeight \n    - householdAutarkyValue\n  ) %>% as.numeric\n  villageDiffLCRiskSharingAndAutarky <- (\n    calculateUtility(aggregateIncome - householdConsumption, sigma) \n    + delta * incomeTransitionProbVec %*% villageValueLCRiskSharingAtRelativeParetoWeight \n    - villageAutarkyValue\n  ) %>% as.numeric\n\n  return(list(\n    householdDiffLCRiskSharingAndAutarky = householdDiffLCRiskSharingAndAutarky,\n    villageDiffLCRiskSharingAndAutarky = villageDiffLCRiskSharingAndAutarky\n  ))\n}\n\ngetClosestGridIndex <- function(\n  point,\n  gridPoints\n) {\n  closestGridIndex <- which.min(\n    abs(point - gridPoints) \n  )\n  if (\n    point \n    > gridPoints[closestGridIndex]\n    ) {\n    closestGridIndex <- closestGridIndex + 1\n  }\n  return(closestGridIndex)\n}\n\ncalculateValueLCRiskSharing <- function(\n  valueFullRiskSharing,\n  consumptionOnRelativeParetoWeightGrid,\n  aggregateIncomeGridPoints,\n  incomeTransitionMatrix,\n  autarkyValueMatrix,\n  relativeParetoWeightsGridPoints,\n  numRelativeParetoWeights,\n  delta,\n  sigma,\n  numIncomeStates,\n  iterationLimit,\n  diffLimit\n) {\n  \n  # Initial guess is expected utilities under full risk sharing\n  householdValueLCRiskSharing <- valueFullRiskSharing$householdValueFullRiskSharing\n  villageValueLCRiskSharing <- valueFullRiskSharing$villageValueFullRiskSharing\n  \n  relativeParetoWeightBounds <- matrix(NA, nrow = numIncomeStates, ncol = 2)\n  \n  diff <- 1\n  iteration <- 1\n  while ((diff > diffLimit) && (iteration <= iterationLimit)) {\n    \n    # First, ignore enforceability and just update the value functions\n    # using the values at the previous iteration\n    householdValueLCRiskSharingNew <- (\n      calculateUtility(consumptionOnRelativeParetoWeightGrid, sigma) \n      + delta * incomeTransitionMatrix %*% householdValueLCRiskSharing\n    )\n    villageValueLCRiskSharingNew <- (\n      calculateUtility(aggregateIncomeGridPoints - consumptionOnRelativeParetoWeightGrid, sigma) \n      + delta * incomeTransitionMatrix %*% villageValueLCRiskSharing\n    )\n    \n    # Now check enforceability at each state\n    for (incomeStateIndex in seq(1, numIncomeStates)) {\n      aggregateIncome <- aggregateIncomeGridPoints[incomeStateIndex]\n      incomeTransitionProbVec <- incomeTransitionMatrix[incomeStateIndex,]\n      householdAutarkyValue <- autarkyValueMatrix[incomeStateIndex, 1]\n      villageAutarkyValue <- autarkyValueMatrix[incomeStateIndex, 2]\n      \n      diffLCRiskSharingAndAutarky <- map(\n        c(min(relativeParetoWeightsGridPoints), max(relativeParetoWeightsGridPoints)),\n        ~ calculateDiffLCRiskSharingAndAutarky(\n          .,\n          relativeParetoWeightsGridPoints,\n          delta,\n          sigma,\n          aggregateIncome,\n          householdValueLCRiskSharing,\n          villageValueLCRiskSharing,\n          incomeTransitionProbVec,\n          householdAutarkyValue,\n          villageAutarkyValue\n          )   \n      ) %>% \n        setNames(c(\"minRelativeParetoWeight\", \"maxRelativeParetoWeight\"))\n      \n      # If the relative Pareto weight is too low and violates the PC, then\n      # set the relative Pareto weight to the lower bound of the interval, and\n      # HH gets the value under autarky.\n      if (\n        (diffLCRiskSharingAndAutarky %>% \n         .$maxRelativeParetoWeight %>% \n         .$householdDiffLCRiskSharingAndAutarky > 0) \n        && (diffLCRiskSharingAndAutarky %>% \n            .$minRelativeParetoWeight %>% \n            .$householdDiffLCRiskSharingAndAutarky < 0)) {\n        \n        relativeParetoWeightLowerBound <- uniroot(\n          function(x) {calculateDiffLCRiskSharingAndAutarky(\n            x,\n            relativeParetoWeightsGridPoints,\n            delta,\n            sigma,\n            aggregateIncome,\n            householdValueLCRiskSharing,\n            villageValueLCRiskSharing,\n            incomeTransitionProbVec,\n            householdAutarkyValue,\n            villageAutarkyValue\n            )$householdDiffLCRiskSharingAndAutarky}, \n          c(min(relativeParetoWeightsGridPoints), max(relativeParetoWeightsGridPoints)), \n          tol = 1e-10, \n          maxiter = 300\n          )$root\n        relativeParetoWeightBounds[incomeStateIndex, 1] <- relativeParetoWeightLowerBound\n\n        relativeParetoWeightLowerBoundIndex <- getClosestGridIndex(\n          relativeParetoWeightLowerBound,\n          relativeParetoWeightsGridPoints\n        )\n        \n        villageValueLCRiskSharingLowerBound <- interpolateValueFunction(\n          relativeParetoWeightLowerBound,\n          relativeParetoWeightsGridPoints,\n          villageValueLCRiskSharing\n        )\n        \n        householdConsumptionLowerBound <- calculateConsumption(\n          aggregateIncome,\n          relativeParetoWeightLowerBound,\n          sigma\n        )       \n        \n        householdValueLCRiskSharingNew[\n          incomeStateIndex, \n          seq(1, relativeParetoWeightLowerBoundIndex)\n          ] <- householdAutarkyValue\n        villageValueLCRiskSharingNew[\n          incomeStateIndex, \n          seq(1, relativeParetoWeightLowerBoundIndex)\n          ] <- (\n          calculateUtility(aggregateIncome - householdConsumptionLowerBound, sigma)\n          + delta * incomeTransitionProbVec %*% villageValueLCRiskSharingLowerBound\n        )\n      } else if (\n        diffLCRiskSharingAndAutarky %>% \n        .$maxRelativeParetoWeight %>% \n        .$householdDiffLCRiskSharingAndAutarky <= 0\n        ) {\n        householdValueLCRiskSharingNew[incomeStateIndex,] <- householdAutarkyValue\n        villageValueLCRiskSharingNew[incomeStateIndex,] <- villageAutarkyValue\n        relativeParetoWeightBounds[incomeStateIndex, 1] <- max(relativeParetoWeightsGridPoints)\n        relativeParetoWeightLowerBoundIndex <- numRelativeParetoWeights + 1\n      } else if (\n        diffLCRiskSharingAndAutarky %>% \n        .$minRelativeParetoWeight %>% \n        .$householdDiffLCRiskSharingAndAutarky >= 0\n        ) {\n        relativeParetoWeightBounds[incomeStateIndex, 1] <- min(relativeParetoWeightsGridPoints)\n        relativeParetoWeightLowerBoundIndex <- 0\n      }\n    \n      # If the relative Pareto weight is too high and violates the PC, then\n      # set the relative Pareto weight to the upper bound of the interval, and\n      # village gets the value under autarky.\n      if (relativeParetoWeightLowerBoundIndex <= numRelativeParetoWeights) {\n        if (\n          (diffLCRiskSharingAndAutarky %>% \n           .$minRelativeParetoWeight %>% \n           .$villageDiffLCRiskSharingAndAutarky > 0)\n          && (diffLCRiskSharingAndAutarky %>% \n              .$maxRelativeParetoWeight %>% \n              .$villageDiffLCRiskSharingAndAutarky < 0)\n          ) {\n          \n          relativeParetoWeightUpperBound <- uniroot(\n            function(x) {calculateDiffLCRiskSharingAndAutarky(\n              x,\n              relativeParetoWeightsGridPoints,\n              delta,\n              sigma,\n              aggregateIncome,\n              householdValueLCRiskSharing,\n              villageValueLCRiskSharing,\n              incomeTransitionProbVec,\n              householdAutarkyValue,\n              villageAutarkyValue\n              )$villageDiffLCRiskSharingAndAutarky}, \n            c(min(relativeParetoWeightsGridPoints), max(relativeParetoWeightsGridPoints)), \n            tol = 1e-10, \n            maxiter = 300\n            )$root\n          relativeParetoWeightBounds[incomeStateIndex, 2] <- relativeParetoWeightUpperBound\n          \n          relativeParetoWeightUpperBoundIndex <- getClosestGridIndex(\n            relativeParetoWeightUpperBound,\n            relativeParetoWeightsGridPoints\n          )\n           \n          householdValueLCRiskSharingUpperBound <- interpolateValueFunction(\n            relativeParetoWeightUpperBound,\n            relativeParetoWeightsGridPoints,\n            householdValueLCRiskSharing\n          )\n          \n          householdConsumptionUpperBound <- calculateConsumption(\n            aggregateIncome,\n            relativeParetoWeightUpperBound,\n            sigma\n          )       \n          \n          householdValueLCRiskSharingNew[\n            incomeStateIndex, \n            seq(relativeParetoWeightUpperBoundIndex, numRelativeParetoWeights)\n            ] <- (\n            calculateUtility(householdConsumptionUpperBound, sigma)\n            + delta * incomeTransitionProbVec %*% householdValueLCRiskSharingUpperBound\n            )\n          villageValueLCRiskSharingNew[\n            incomeStateIndex, \n            seq(relativeParetoWeightUpperBoundIndex, numRelativeParetoWeights)\n            ] <- villageAutarkyValue\n        } else if (\n          (diffLCRiskSharingAndAutarky %>% \n           .$minRelativeParetoWeight %>% \n           .$villageDiffLCRiskSharingAndAutarky <= 0)\n          ) {\n          householdValueLCRiskSharingNew[incomeStateIndex,] <- householdAutarkyValue\n          villageValueLCRiskSharingNew[incomeStateIndex,] <- villageAutarkyValue\n          relativeParetoWeightBounds[incomeStateIndex, 2] <- min(relativeParetoWeightsGridPoints)\n          relativeParetoWeightUpperBoundIndex <- 0\n        } else if (\n          (diffLCRiskSharingAndAutarky %>% \n           .$maxRelativeParetoWeight %>% \n           .$villageDiffLCRiskSharingAndAutarky >= 0)\n          ) {\n          relativeParetoWeightBounds[incomeStateIndex, 2] <- max(relativeParetoWeightsGridPoints)\n          relativeParetoWeightUpperBoundIndex <- numRelativeParetoWeights + 1\n        }\n      }\n      \n      # The case where the relative Pareto weight does not violate PC\n      if ((relativeParetoWeightLowerBoundIndex + 1) < (relativeParetoWeightUpperBoundIndex - 1)) {\n        householdValueLCRiskSharingNew[\n          incomeStateIndex, \n          (relativeParetoWeightLowerBoundIndex + 1):(relativeParetoWeightUpperBoundIndex - 1)\n          ] <- (\n            calculateUtility(\n              consumptionOnRelativeParetoWeightGrid[\n                incomeStateIndex, \n                (relativeParetoWeightLowerBoundIndex + 1):(relativeParetoWeightUpperBoundIndex - 1)\n                ], \n              sigma\n              ) \n            + delta * incomeTransitionProbVec %*% householdValueLCRiskSharing[\n              , (relativeParetoWeightLowerBoundIndex + 1):(relativeParetoWeightUpperBoundIndex - 1)\n            ]\n          )\n        villageValueLCRiskSharingNew[\n          incomeStateIndex, \n          (relativeParetoWeightLowerBoundIndex + 1):(relativeParetoWeightUpperBoundIndex - 1)\n          ] <- (\n            calculateUtility(\n              aggregateIncome - consumptionOnRelativeParetoWeightGrid[\n                incomeStateIndex, \n                (relativeParetoWeightLowerBoundIndex + 1):(relativeParetoWeightUpperBoundIndex - 1)\n                ], \n              sigma) \n            + delta * incomeTransitionProbVec %*% villageValueLCRiskSharing[\n              , (relativeParetoWeightLowerBoundIndex + 1):(relativeParetoWeightUpperBoundIndex - 1)\n              ] \n            )\n        }\n      }   \n\n    diff <- max(\n      max(abs(householdValueLCRiskSharingNew - householdValueLCRiskSharing)),\n      max(abs(villageValueLCRiskSharingNew - villageValueLCRiskSharing))\n    )\n    householdValueLCRiskSharing <- householdValueLCRiskSharingNew\n    villageValueLCRiskSharing <- villageValueLCRiskSharingNew\n    iteration <- iteration + 1\n  }\n  \n  print(iteration)\n\n  if (iteration == iterationLimit) {\n    print(\"Reached the maximum limit of iterations!\")\n  }\n  \n  return(list(\n    householdValueLCRiskSharing = householdValueLCRiskSharing,\n    villageValueLCRiskSharing = villageValueLCRiskSharing,\n    relativeParetoWeightBounds = relativeParetoWeightBounds))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsolveLCRiskSharingByVillage <- function(\n    delta,\n    sigma,\n    punishment,\n    householdIncomeTransitionMatrix,\n    householdIncomeGridPoints,\n    villageIncomeTransitionMatrix,\n    villageIncomeGridPoints,\n    numRelativeParetoWeights = 200,\n    iterationLimit = 100,\n    diffLimit = 1e-8\n){\n  \n  incomeTransitionMatrix <- kronecker(\n    villageIncomeTransitionMatrix,\n    householdIncomeTransitionMatrix\n    )\n  \n  numIncomeStates <- length(householdIncomeGridPoints) * length(villageIncomeGridPoints)\n  \n  incomeGridPointsMatrix <- as.matrix(expand.grid(\n    householdIncomeGridPoints, villageIncomeGridPoints\n    ))\n  \n  aggregateIncomeGridPoints <- rowSums(incomeGridPointsMatrix)\n  \n  autarkyValueMatrix <- expand.grid(\n    calculateAutarkyValue(\n      householdIncomeGridPoints,\n      sigma,\n      delta,\n      punishment,\n      householdIncomeTransitionMatrix\n    ),\n    calculateAutarkyValue(\n      villageIncomeGridPoints,\n      sigma,\n      delta,\n      punishment,\n      villageIncomeTransitionMatrix\n    )\n  )\n  \n  relativeParetoWeightsGridPoints <- getRelativeParetoWeightsGridPoints(\n      sigma,\n      punishment,\n      householdIncomeGridPoints,\n      villageIncomeGridPoints,\n      numRelativeParetoWeights\n      )\n  \n  consumptionOnRelativeParetoWeightGrid <- matrix(\n    NA, nrow = numIncomeStates, ncol = numRelativeParetoWeights\n    )\n  for (incomeStateIndex in seq_along(aggregateIncomeGridPoints)) {\n    for (relativeParetoWeightIndex in seq_along(relativeParetoWeightsGridPoints)) {\n      consumptionOnRelativeParetoWeightGrid[\n        incomeStateIndex, \n        relativeParetoWeightIndex\n        ] <- calculateConsumption(\n          aggregateIncomeGridPoints[incomeStateIndex],\n          relativeParetoWeightsGridPoints[relativeParetoWeightIndex],\n          sigma\n        )\n      }\n    }\n\n  valueFullRiskSharing <- calculateValueFullRiskSharing(\n    incomeTransitionMatrix, \n    aggregateIncomeGridPoints, \n    delta, \n    sigma, \n    autarkyValueMatrix, \n    consumptionOnRelativeParetoWeightGrid,\n    numRelativeParetoWeights\n    )\n\n  valueLCRiskSharing <- calculateValueLCRiskSharing(\n    valueFullRiskSharing,\n    consumptionOnRelativeParetoWeightGrid,\n    aggregateIncomeGridPoints,\n    incomeTransitionMatrix,\n    autarkyValueMatrix,\n    relativeParetoWeightsGridPoints,\n    numRelativeParetoWeights,\n    delta,\n    sigma,\n    numIncomeStates,\n    iterationLimit,\n    diffLimit\n  )\n\n  return(valueLCRiskSharing)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsave.image(\"IntermediateData/lc_hom_model_functions.RData\")\n```\n:::\n\n\n### Sanity test: replication of Figure 1 in @Ligon2002\n\nFor the sanity test of this function, I use it to replicate the Figure 1 in @Ligon2002.\nHere I use the parameter values in the original paper.\nI choose the income process $(y_l, y_h) = (2/3, 4/3)$ and $(p_l, p_h) = (0.1, 0.9)$ for both households so that the mean is $1$ and the ratio $y_l / y_h$ is 1/2 as in the paper.\nAlso, the penalty under autarky is absent as in the original numerical exercise.\nFinally, I assume the CRRA utility functions:\n\n$$\n  u(c_{it}) = \\frac{c_{it}^{1 - \\sigma} - 1}{1 - \\sigma}.\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsigmaLTW <- 1.0\npunishmentLTW <- 0.0\n\nincomeTransitionMatrixLTW <- matrix(rep(c(0.1, 0.9), 2), nrow = 2, byrow = TRUE)\nincomeGridPointsLTW <- c(2/3, 4/3)\nnumIncomeStates <- length(incomeGridPointsLTW) *  length(incomeGridPointsLTW)\n\ndeltaVec <- seq(0.8, 0.999, by = 0.002)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsolveLCRiskSharingByVillage(\n  0.9,\n  sigmaLTW,\n  punishmentLTW,\n  incomeTransitionMatrixLTW,\n  incomeGridPointsLTW,\n  incomeTransitionMatrixLTW,\n  incomeGridPointsLTW,\n  numRelativeParetoWeights = 400,\n  iterationLimit = 1000,\n  diffLimit = 1e-8\n  )\n\nLCRiskSharingResultLTW <- map(\n  deltaVec,\n  ~ solveLCRiskSharingByVillage(\n    .,\n    sigmaLTW,\n    punishmentLTW,\n    incomeTransitionMatrixLTW,\n    incomeGridPointsLTW,\n    incomeTransitionMatrixLTW,\n    incomeGridPointsLTW,\n    numRelativeParetoWeights = 400,\n    iterationLimit = 1000,\n    diffLimit = 1e-8\n    )\n)\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrelativeParetoWeightBoundsArray = array(\n  NA, \n  dim = c(numIncomeStates, 2, length(deltaVec))\n  )\n\nfor (deltaIndex in seq_along(deltaVec)) {\n  relativeParetoWeightBoundsArray[,,deltaIndex] <- (\n    LCRiskSharingResultLTW[[deltaIndex]]$relativeParetoWeightBounds\n  )\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_line(aes(deltaVec, log(relativeParetoWeightBoundsArray[1,1,]), color = \"a\")) +\n  geom_line(aes(deltaVec, log(relativeParetoWeightBoundsArray[1,2,]), color = \"b\")) +\n  geom_line(aes(deltaVec, log(relativeParetoWeightBoundsArray[2,1,]), color = \"c\")) +\n  geom_line(aes(deltaVec, log(relativeParetoWeightBoundsArray[2,2,]), color = \"d\")) +\n  geom_line(aes(deltaVec, log(relativeParetoWeightBoundsArray[3,1,]), color = \"e\")) +\n  geom_line(aes(deltaVec, log(relativeParetoWeightBoundsArray[3,2,]), color = \"f\")) +\n  geom_line(aes(deltaVec, log(relativeParetoWeightBoundsArray[4,1,]), color = \"g\")) +\n  geom_line(aes(deltaVec, log(relativeParetoWeightBoundsArray[4,2,]), color = \"h\")) +\n  coord_cartesian(\n    xlim = c(0.8, 1.0), \n    ylim = c(\n      log(incomeGridPointsLTW[1] / incomeGridPointsLTW[2]),\n      log(incomeGridPointsLTW[2] / incomeGridPointsLTW[1])\n      )\n    ) +\n  geom_ribbon(aes(x = deltaVec,\n                  ymin = log(relativeParetoWeightBoundsArray[1,1,]),\n                  ymax = log(relativeParetoWeightBoundsArray[1,2,])),\n                  fill = \"blue\", alpha = 0.2) +\n  geom_ribbon(aes(x = deltaVec,\n                  ymin = log(relativeParetoWeightBoundsArray[2,1,]),\n                  ymax = log(relativeParetoWeightBoundsArray[2,2,])),\n                  fill = \"red\", alpha = 0.2) +\n  geom_ribbon(aes(x = deltaVec,\n                  ymin = log(relativeParetoWeightBoundsArray[3,1,]),\n                  ymax = log(relativeParetoWeightBoundsArray[3,2,])),\n                  fill = \"green\", alpha = 0.2) +\n  geom_ribbon(aes(x = deltaVec,\n                  ymin = log(relativeParetoWeightBoundsArray[4,1,]),\n                  ymax = log(relativeParetoWeightBoundsArray[4,2,])),\n                  fill = \"yellow\", alpha = 0.2) +\n  scale_color_manual(\n    name = \"End-points\",\n    values = c(\n      \"blue\",\n      \"purple\",\n      \"brown\",\n      \"red\",\n      \"yellow\",\n      \"green\",\n      \"orange\",\n      \"gray\"\n      ),\n    labels = unname(TeX(c(\n      \"$\\\\underline{x}_{ll}$\",\n      \"$\\\\bar{x}_{ll}$\",\n      \"$\\\\underline{x}_{hl}$\",\n      \"$\\\\bar{x}_{hl}$\",\n      \"$\\\\underline{x}_{lh}$\",\n      \"$\\\\bar{x}_{lh}$\",\n      \"$\\\\underline{x}_{hh}$\",\n      \"$\\\\bar{x}_{hh}$\"\n      )))\n    ) +\n  xlab(\"Discount factor (delta)\") +\n  ylab(\"log of the relative Pareto weights (x)\") +\n  theme_classic()\n```\n\n::: {.cell-output-display}\n![](laczo2015_lc_hom_model_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "laczo2015_lc_hom_model_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}